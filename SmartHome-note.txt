1.按键控制播放器
有一个数学领域的猜想，名为Six Degrees of Separation，中文翻译有以下几种： 六度分割理论、六度空间理论以及小世界理论等。
查看网页源码，审查元素
利用打印修改错误
错误往往发生在重复不注意的地方
一般毕业6k起薪，年薪不低于6万，专科生不能签就业协议
工作三年后12-18k  
普通程序员18-20k到顶
工作经验8-10年税后50万
培训班18000，4个月，少于25人一般亏本
智联招聘
不可替代
浪潮：服务器
嵌入式开发
linux运维
外包企业没有归属感，做完就走人
H5
无人机，物联网，服务器
61单片机
linux系统必学
集群：分布式计算
opencv流媒体
同步互斥
tcpip协议，路由器项目
C++门禁，服务器
文件系统，电容屏幕驱动
who命令
实现shell命令解析器
bootloader
proc
图片排序算法
人工智能需求500万人，布局较晚，美国已经从事了100万人，中国5.5万人第7，工资100万，联想人工智能，联想研发成本2%，华为13%，谷歌15%，都在做人工智能，TP-LINK窄带物联网。其他行业产业链较长，程序员面向用户，所以待遇好
看简历看技能，知识点，加分项：项目，项目经验，别超过两页
volatile ：(int i;i++; i<=100)
默认编译器最终将定义的整形变量i只保存一次最终结果，即为100,而不是保存100次，每次累加。
restrict：限制指针。restrict关键字（暗示编译器，某个指针指向的空间，只能从该指针访问），再定义一个就不能修改
内核
段错误
用宏定义可以取出其中的每个字段
通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会退出（写进程会收到SIGPIPE信号）。
zigbee协议栈
无线通信协议
模电数电数据结构操作系统
c ，linux ，linux网络，c++，内核
守护进程，通常所说的Daemon进程，常常在系统引导载入时启动，在系统关闭时终止。大多数后台服务都是通过守护进程实现的。如果想让某个进程脱离控制终端，那么就必须把这个进程变成一个守护进程。

在linux 中每一个进程都由task_struct 数据结构来定义. task_struct就是我们通常所说的PCB.她是对进程控制的唯一手段也是最有效的手段. 当我们调用fork() 时, 系统会为我们产生一个task_struct结构。然后从父进程,那里继承一些数据, 并把新的进程插入到进程树中, 以待进行进程管理。因此了解task_struct的结构对于我们理解任务调度(在linux 中任务和进程是同一概念)的关键。
---------------------------------------------------------------
2017.7.11 AM
--------------------------------------------------------------
快捷键main：\im
快捷键printf:\ip
内存，进程空间
标准库函数依赖的是 system call。
对文件进行操作必须要通过内核，也就是需要进行系统调用（接口）
系统调用：函数，库，50-60 共300个，接口，与内核交流
文件IO:open()
黑客军团
posix：库
文件IO(系统调用):open()，返回文件描述符，0123，对文件操作就是对数字操作
标准IO：fopen()
句柄：指向结构体的指针
打开文件有一个文件描述符
man 2 open 查看函数open()头文件

FILE *p=fopen(a);库函数，内存
int fd=open(a);系统调用，内核，磁盘
库函数实现缓冲区：
while(1) 行缓冲\n 刷新缓冲区作用
printf函数缓冲区，直到满了再write(),减少资源浪费
printf()库函数调用 ->write(1,...);
默认fd=3 ,012被占用 yang.c

cat yang.txt

优先级：
char *argv[]  指针数组，每个元素是指针，存的是地址
指针  数组

指针*p都是4个字节,指针就是编号，0x00 00 00 00共四个字节。0xff ff ff ff共4G

char* p
int* p

---------------------------------------------------------------------
2017.7.11 PM
----------------------------------------------------------------------
strlen用来求字符串的长度用的
而sizeof是用来求指定变量或者变量类型等所占内存大小用的
比如strlen（"nihao"）它的结果是5
而sizeof(int)它的结果是2也就是说int型占两个字节
strlen指字符的大小
sizeof指文件或者数据占的内存(字节)
sizeof是操作符（关键字），strlen是函数。
      char str[20]="0123456789";
      int len1=strlen(str); //len1=10;
      int len2=sizeof(str); //len2=20;

file命令查看文件类型：file /bin/bash
ulimit -n 查看系统允许进程打开文件的数量
DOS下查看帮助：find /? 
内核其实不是必要的，但后来管理的任务多了就产生了
块设备 /dev；字符型设备
删除多个文件：rm -rf dir1 dir2
作业，进程
xmanager
-----------------------------------------------
1. sys/tpyes.h是Unix/Linux系统的基本系统数据类型的头文件，含有size_t，time_t，pid_t等类型。pid_t是一个预定义的类型，也就是int
2. sys/stat.h 轻松获取文件属性
3. fcntl.h头文件定义了文件操作控制等所用到的相关宏。
4. unistd.h 是 C 和 C++ 提供对 POSIX 操作系统 API 的访问功能的头文件的名称。该头文件由 POSIX.1 标准（单一UNIX规范的基础）提出，故所有遵循该标准的操作系统和编译器均应提供该头文件（如 Unix 的所有官方版本，包括 Mac OS X、Linux 等）。
   对于类 Unix 系统，unistd.h 中所定义的接口通常都是大量针对系统调用的封装（英语：wrapper functions），如 fork、pipe 以及各种 I/O 原语（read、write、close 等等）。
-------------------------------------------------------
exit() 函数与 _exit() 函数的最大区别在于exit()函数在调用exit  系统调用前要检查文件的打开情况，把文件缓冲区中的内容写回文件。也就是图中的“清理I/O缓冲”。

exit是退出去先把内存中的数据输出到文件中，而_exit 这个直接退出，消除内存中的数据；

printf是标准行输出，遇到“\n”或者是写入的内存满了才会标准输出；

----------------------------------------------------------
操作系统：设备和资源关联起来

程序:可执行文件。注意，.c不是程序，而是文本
进程：将一个可执行文件.exe运行起来。系统会开辟内存空间，是一个容器，处理器，空间，资源，计数器，环境变量，代码，寄存器，程序运行许需要的所有资源。每个进程都是一个任务
由fork()创建
./ bash命令解析-> exec函数执行程序

进程调度算法：时间片轮转。cpu（qq,wechat,fq）

就绪：等待 cpu时间。钱和身份证
等待：等待 条件。钱不够

PCB:进程空间，数据结构，结构体，出生档案

UMASK掩码：屏蔽权限0777 0707 

进程上下文：运行过的代码，未运行的代码

进程号：typedef uint pid_t

文件流 文件描述符：stdin 0,stdout 1,stderr 2。以后打开的依次增加
fileno()函数返回一个流对应的文件描述符
1号进程为祖先
fd:file description 为定义的文件描述符参数
组进程：PGID，给组进程发送信号

ps -a 查看进程

LS ：跑车

返回值>0

复制品：子进程看不见，本来fork后子进程从main()开始执行。但实际上是独立同时运行的，两个进程
但代码是一个。
fork()之后父进程空间独立的
多个进程可以实现多任务
默认进程会被分配4G进程0x0000 0000-0xffff ffff
打印地址：printf()

栈：局部变量
堆：动态申请的
BSS和数据区:已经初始化的全局静态区 和 未初始化的全局静态区

全局：生命周期
static：作用域

\n 刷新缓冲区，不加\n，数据不刷新，接着读而不是从头读
fork()创建子进程时，复制了父进程的数据段和堆栈段，包括上面所讲的缓冲区。

通常fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间 
而vfork就把事情做绝了，所有有关于内存的东西都不复制了，父子进程的内存是完全共享的。
在exec()exit()之前没有自己的地址空间
孤儿进程
给父进程（组）信号，父进程死掉，子进程不受控制，crtl+c不能中止子进程
ps
kill 进程号

vfork保证子进程先运行，父进程被阻塞
exit()：子进程占据父进程空间，等子进程死掉后运行stdlib.h。man exit查看头文件
exec()：启动一个程序新空间，将一个程序运行起来，媳妇。
子进程一定要有exit(1)，不加会出问题
env:查看环境变量

fork()不变，vfork变，地址空间用父亲的，即父亲等儿子用完后用

换一个终端即可启用失效的path

vi bash.rc一样
bash->exec()->启动

NULL传递参数结束

隐藏文件. .. ，exit(1)

ls -h 人性化显示，如4096字节显示为4K
fork 创建一个新进程
execve 运行可执行文件
exit 中止进程
_exit 立即中止当前进程
wait 等待子进程终止
vfork 创建一个子进程，以供执行新程序，常与execve等同时使用

dup 复制已打开的文件描述字

Wait()函数将挂起调用进程直到获得了它的子进程的状态信息，或者是直到获得一个终止进程信号；
linux下有终端和控制台两个概念，
开发板下：终端就特指串口，即ttySAC0(也就是s3c2410_serial0)，而控制台分为两种：1、console;2、虚拟控制台、tty0-tty63;控制台是连接实际物理设备的说法，虚拟控制台可以有多个，像在虚拟机的字符界面下看到的就是tty1-tty63，也就是所谓的虚拟控制台，但console作为控制台是一个概念，我们可以把开发板的LCD当成控制台，也可以把开发板的串口当成控制台。tty命令可以查看当前的登陆设备。有人问，那我们通常看到的pts呢？那是什么呢？那叫伪终端，是unix98或是BSD提供的一种端到端的通信方法

内部命令：内部命令被构建在shell之中。当执行shell命令时，内部命令的执行速度非常快。这是因为没有其他的进程因为执行这条命令而被创建。比如说，当我们执行“cd”命令时，没有进程被创建。在执行过程中只是简单的改变当前的目录。
外部命令：外部命令并没有被构建在shell中。这些可执行的外部命令保存在一个独立的文件当中。当一个外部命令被执行时，一个新的进程即被创建同时命令被执行。
---------------------------------------------------------------------
2017.7.12 AM
----------------------------------------------------------------------
进程：资源分配单位
线程：调度单位

restrict：限制指针

进程间通信：信号，管道，消息队列，共享内存

父进程创建一个无名管道，返回两个文件描述符，3读4写，子管道也可以进行读写，实现通信

在fork()之前创建管道，子进程才能复制创建的管道，实现通信

管道存在内存中，缓冲区中，断电消失
无名管道用于创建父子进程中使用，每个进程中的文件描述符不一样，尽管3 4 一样，且只在当前进程中有效

0==pid 常用
0=pid  变量不能给常量赋值

命名管道：文件系统，有名字，不相关的进程也可以通信，存在磁盘中，断电不消失，下次还可以用，只有一个文件描述符，数据读完就没有了
两个进程，写进程不能结束退出，否则内存内容消失，读不出来可用while(1)循环防止写进程死掉
先运行写，后运行读进程

运行时候需要开两个终端

mplayer songName 播放音乐，p暂停，0 9 音量加减，左右键快进

mplayer -idle -slave -quiet ./shanghaitan

gets()：会溢出，内存污染，可能写到别人空间去了
fgets():得到所有字符

阻塞在gets()
首先创建管道
fork()一个子进程，子进程exec(mplayer)

while(1)
mplayer默认在命名管道读数据

crtl+c


----------
1.创建一个线程，通过管道给mplayer发送命令，获取
所需要的消息，比如歌手，播放当前时间，歌曲总时间，
可是mplayer把信息显示到屏幕了，所以需要把mplayer播放的信息重定向到另一个管道里，我们才可以得到
2.创建一个线程，主要是为了得到mplayer播放的信息，
3.把得到信息解析后把它显示在标签上
4.实现点击进度条快进快退


---------------------------------------------------------------------
2017.7.12 PM
----------------------------------------------------------------------

文本编辑器：notepad++
代码编辑器：sublime,sourceinsight(吃内存，电脑配置高)
F12跳到对应函数定义处

--------------------------

线程：进程中一个独立的代码执行块
进程间通信需要用管道
线程存在于进程中，共享内存空间，通信简单
cpu执行的是进程中的线程，cpu执行的基本单位
进程是一个容器，是一个资源
默认有一个主线程，也就是mian()函数，可以有多个线程，资源从进程中拿，流水线，只占用栈区

轻量级服务器：多线程几十个，线程池100左右
大型服务器：select千个，epoll,万个，IO复用； poll,nginx

4核8线程，每个任务一个线程处理

改变值需要传地址，NULL

根据优先级判断：
char *buf[]:指针数组，首先是一个数组，然后指针，反过来念
char (*buf)[]:保存一个数组的地址，四个字节
void* (*start_routine)(void *)：void* (指针)（函数）
函数指针：函数名，函数入口地址

void *arg ：万能指针，传给线程函数的参数

-lpthread:添加库链接，找到.h

*p：取指向地址空间的内容
（ int*）： 取四个字节，强制转换后才知道取几个字节
抵消一个* ：int b = *(int*)，也就是两边都是int类型
对表达式取*，就会使表达式减一个*
对表达式取&，就会使表达式多一个*

join主线程等待子线程退出，回收子线程资源

void**: void*类型的地址,void *p ->&p

局部变量结束地址空间会交给系统，读的不符合，写会相互错，不能返回局部地址，地址释放就不能返回

栈区用完释放，能不能返回地址，看地址指向的空间有没有释放
堆区不释放(int*)malloc(4)

结构体：为什么要用指针，传地址，只传一个地址变量，传一个结构体地址就可以传递所有变量参数

进程的地址空间：非常重要！！！

-----------------------------------------
类型定义
1. 整数类型：gint8、guint8、gint16、guint16、gint31、guint32、gint64、guint64。不是所有的平台都提供64位整型

2. 整数类型gshort、glong、gint和short、long、int相同

3. 布尔类型gboolean：gboolean可以取两个值：TRUE和FALSE

4. 字符型gchar和char相同

5. 浮点型gfloat和gdouble和float、double完全等价

6. 指针gpointer对应于标准C的void*

7. const gpointer对于于标准C的const void*
----------------------------------------
COLOR [attr]

  attr        指定控制台输出的颜色属性。

颜色属性由两个十六进制数字指定 -- 第一个
对应于背景，第二个对应于前景。每个数字
可以为以下任何值:

    0 = 黑色       8 = 灰色
    1 = 蓝色       9 = 淡蓝色
    2 = 绿色       A = 淡绿色
    3 = 浅绿色     B = 淡浅绿色
    4 = 红色       C = 淡红色
    5 = 紫色       D = 淡紫色
    6 = 黄色       E = 淡黄色
    7 = 白色       F = 亮白色

如果没有给定任何参数，此命令会将颜色还原到 CMD.EXE 启动时
的颜色。这个值来自当前控制台
窗口、/T 命令行开关或 DefaultColor 注册表
值。
---------------------------------------------------------------------
2017.7.13 AM
--------------------------------------------------------------------

指针：(4字节)地址，编号。每一字节的地址编号
       0x0000 0000- 0x0000 0001...
指针变量：用来保存地址的变量
指针如何定义：需要看这个指针变量用来保存什么类型数据的地址
1.把需要保存的八个变量的地址放在此处int num;  
2.*p  
3.替换 int *p
4.在定义的时候初始化 int *p=&num
  在使用的时候初始化  p=&num
  %p打印地址：printf("p===%p\n",p);----------4字节
  %d打印大小：printf("p===%d\n",sizeof(p));--4字节
  sizeof()测变量数据类型的大小,所有指针都是4字节
5.通过指针变量取指针变量指向内存空间的内容：加*
6.对表达式取&,加一级*；取*对整个表达式减少一级
取内容不一样：
打印16进制：%#x
--------
int num = 0x01020304
int* p;
char* p1
;short*  p2 ;
p = p1 = p2 = &num
printf("p=%#x, p2=%#x, p2=%#x",*p,*p1,*p2);

结果：p=0x01020304  p1=0x04  p2=0x0304
----------
双通道内存
makefile:编译，$取变量

crtl+n：vi下自动补全

段错误：访问内存内容失败

static:只在当前文件.c可用

指向控件的指针:GtkWidget *image

---------------------------------------------------------------------
2017.7.14 PM
--------------------------------------------------------------------
1.创建button
2.创建图片对象资源，磁盘中的图片放到内存中
3.修改图片对象资源
4.生成image
5.image设置到button控件中

一个Gnome程序使用多个库组成的层次结构： 
       Gnome库在最高层，包括帮助例程，类和特殊的widget，并为应用程序提供一个基础架构。
       第二层是GTK，它是GTK＋库的一部分。这个库提供了基本的工具包和widget来创建GUI应用程序。大多数GUI是直接用GTK编写的。GTK同时为Gnome库提供了一个功能强大的对象系统。 
       再下一层是GDK，它简单的对X函数库进行了包装，只有在我们进行特殊绘画或设置窗口的特殊属性的时候才会用到它.  
       最下面一层是Glib，它是C的一个实用程序库，包括可移植性和一些实用程序功能，以及一些容器类，例如：链表，可变数组，变长字符串，HASH（貌似是哈西表），缓存，一个事件循环和其他有用的结构

static：在当前作用域不会每次都初始化，保留上次改变后的结果

time:一定是全局变量

---------------------------------------------------------------------
2017.7.17 AM
--------------------------------------------------------------------
flags：标志位
结构体数据类型占内存大小：牺牲空间换时间：char,*p,只需要读一次
STU  temp:
变量名：用. ；
指针：用->。

通过结构体指针变量访问用"->"
通过结构体变量访问用"."

比如说：
假设student是个结构体,有一个成员int age

struct student one;
struct student *ptr;
one.age               ptr->age

（结构体实例名）.成员数据
（指向结构体的指针名）->成员数据

struct test
{
  int a;
  int b;
};

struct test t;
struct test* p = &t;
t.a = 4;
p->b = 5;
上面是使用的例子。结构体指针时用'->'.结构体变量时用'.'

段错误:内存空间没申请就用，
内存溢出，内存污染，内存泄漏，没有回收

野指针：没有初始化的指针，p的地址不知道，乱指向，万一指向的空间非法或者已经使用，或者没有申请
int &p=&num;

---------------------------------------------------------------------
2017.7.18 AM
--------------------------------------------------------------------
预编译

extern：外部的函数，在外部的各个c文件中找函数，找到为止

extern int a; //只有一个a，头文件用冒号，包含头文件其实就是复制原话

窗口，播放，歌词解析分别用一个.c文件，再在每个c文件包含各自头文件

make -f Makefile

---------------------------------------------------------------------
2017.7.19 AM
--------------------------------------------------------------------
互斥锁，重定向
每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。

只要main函数不结束，结构体所在的空间就不会被释放，里面的变量就不会变，不会初始化为0

带空格的音乐名不会被播放
单曲循环21个创新


---------------------------------------------------------------------
2017.7.20 AM
--------------------------------------------------------------------
底层：linux文件系统，linux内核，驱动（传感器，摄像头等）
上层：搭建轻量级BOA服务器。企业级apache，tomcat
服务器端口80，默认页面为index.html
服务器访问完整地址：192.168.1.251:80/index.html
每个应用程序有一个或多个端口，应用程序在缓冲区拿
通过手机访问开发板网页，boa下的服务器网页控制各种驱动程序

电容屏：京东方，11条产业线，09年起来。总投资3000亿
对设备文件操作：/dev/gpH0，一个设备文件对应几组引脚
insmod命令-->install module的缩写，用来载入模块，通过模式的方式在需要时载入内核，可使内核精简，高效。此类载入的模块，通常为设备驱动程序.
insmod s

www放在share
vi boa.conf

DocumentRoot /mnt/share/www/
shift+g跳到最后一行:
后台处理
/mnt/share/www/cgi-bin/

kill boa

./boa

脚本语言，接触不到底层，好在不用编译，只需解析即可
javascript，PHP，python，shell，lua(华为)，go,C#

html->js(可以无)->AJAX/XML->cgi(实现网页和开发板设备通信)->设备dev程序 
浏览器解析问题

---------------------------------------------------------------------
2017.7.21 AM
--------------------------------------------------------------------
按键：

输入
上拉为高
输出低电平
































































